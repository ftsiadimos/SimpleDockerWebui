{% extends 'base.html' %}
{% block page_title %}Terminal â€” {{ id[:12] }}{% endblock %}

{% block content %}
<div class="terminal-container shadow">
  <div class="terminal-header">
    <div class="terminal-title">
      <span class="terminal-dot red"></span>
      <span class="terminal-dot yellow"></span>
      <span class="terminal-dot green"></span>
      <span class="text-light ms-2">Terminal</span>
    </div>
    <button type="button" class="btn btn-outline-light btn-sm" onclick="window.history.back();" title="Close terminal">
      <i class="fa fa-times" aria-hidden="true"></i> Close
    </button>
  </div>
  <div id="output" class="terminal-body">
    <div id="log"></div>
    <form id="terminalForm" class="terminal-input-line">
      <span class="terminal-prompt">$</span>
      <input type="text" 
             id="terminalInput" 
             class="terminal-input" 
             autocomplete="off" 
             autofocus
             placeholder="Type a command...">
    </form>
    <div class="terminal-hint">
      Built-in commands: <code>cd</code>, <code>pwd</code>, <code>clear</code>
    </div>
  </div>
</div>

<script>
  const log = document.getElementById('log');
  const output = document.getElementById('output');
  const form = document.getElementById('terminalForm');
  const input = document.getElementById('terminalInput');

  // WebSocket connection
  const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const socket = new WebSocket(`${wsProtocol}//${location.host}/echo?id={{ id }}`);

  // Log message to terminal
  function appendLog(text, className) {
    const formatted = text.replace(/\n/g, '<br>');
    const line = document.createElement('div');
    line.className = className;
    line.innerHTML = formatted;
    log.appendChild(line);
    output.scrollTop = output.scrollHeight;
  }

  // Handle incoming messages
  socket.addEventListener('message', (event) => {
    if (event.data === '__CLEAR__') {
      log.innerHTML = '';
    } else {
      appendLog(event.data, 'output-line');
    }
  });

  // Handle connection events
  socket.addEventListener('open', () => {
    appendLog('Connected to container terminal.', 'output-line');
  });

  socket.addEventListener('close', () => {
    appendLog('Connection closed.', 'error-line');
  });

  socket.addEventListener('error', () => {
    appendLog('Connection error.', 'error-line');
  });

  // Built-in commands for autocompletion
  const builtinCommands = [
    'cd', 'pwd', 'clear', 'ls', 'cat', 'echo', 'help', '?', 'exit'
  ];

  // Handle form submission
  form.addEventListener('submit', (event) => {
    event.preventDefault();
    const command = input.value.trim();
    if (command) {
      appendLog(`$ ${command}`, 'input-line');
      socket.send(command);
      input.value = '';
    }
  });

  // Tab autocompletion for commands
  input.addEventListener('keydown', (event) => {
    if (event.key === 'Tab') {
      event.preventDefault();
      const val = input.value.trim();
      if (!val) return;
      // Only autocomplete first word (the command)
      const parts = val.split(/\s+/);
      if (parts.length === 1) {
        const matches = builtinCommands.filter(cmd => cmd.startsWith(parts[0]));
        if (matches.length === 1) {
          input.value = matches[0] + ' ';
        } else if (matches.length > 1) {
          appendLog(matches.join('    '), 'terminal-hint');
        }
      }
    }
  });

  // Keep input focused
  output.addEventListener('click', () => {
    input.focus();
  });

  // Scroll to bottom on load
  window.addEventListener('load', () => {
    output.scrollTop = output.scrollHeight;
    input.focus();
  });
</script>

{% endblock %}