{% extends 'base.html' %}
{% block page_title %}Inspect Container: {{ container_id[:12] }}{% endblock %}

{% block content %}
<div class="inspect-container shadow">
  <div class="inspect-header">
    <div class="d-flex align-items-center gap-2">
      <i class="fa-solid fa-circle-info text-light" aria-hidden="true"></i>
      <span class="text-light fw-medium">Inspect</span>
    </div>

    <!-- Search bar: highlights matches only (no auto-expand). Use ▲/▼ to navigate & expand specific matches -->
    <div class="input-group ms-3" style="max-width:520px; min-width:180px;">
      <input id="inspectSearchInput" class="form-control form-control-sm" type="text" placeholder="Search inspect..." aria-label="Search inspect">
      <button id="inspectSearchClear" class="btn btn-outline-light btn-sm" type="button" title="Clear search">
        <i class="fa-solid fa-xmark" aria-hidden="true"></i>
      </button>

      <!-- Prev / Next match buttons (will expand and show the matched node) -->
      <button id="inspectPrevBtn" class="btn btn-outline-light btn-sm inspect-nav-btn ms-1" type="button" title="Previous match" aria-label="Previous match" disabled>
        <i class="fa-solid fa-chevron-up" aria-hidden="true"></i>
      </button>
      <button id="inspectNextBtn" class="btn btn-outline-light btn-sm inspect-nav-btn ms-1" type="button" title="Next match" aria-label="Next match" disabled>
        <i class="fa-solid fa-chevron-down" aria-hidden="true"></i>
      </button>

      <span id="inspectSearchCount" class="badge bg-light text-dark ms-2 inspect-count inspect-count-empty" style="align-self:center;">—</span>
    </div>

    <div class="btn-group" role="group" aria-label="Inspect controls">
      <button type="button" id="scrollTopBtn" class="btn btn-outline-light btn-log-control" title="Scroll to top" data-bs-toggle="tooltip">
        <i class="fa-solid fa-arrow-up" aria-hidden="true"></i> Top
      </button>
      <button type="button" id="scrollBottomBtn" class="btn btn-outline-light btn-log-control" title="Scroll to bottom" data-bs-toggle="tooltip">
        <i class="fa-solid fa-arrow-down" aria-hidden="true"></i> Bottom
      </button>
      <button type="button" id="downloadBtn" class="btn btn-outline-success btn-log-control" title="Download inspect data" data-bs-toggle="tooltip">
        <i class="fa-solid fa-download" aria-hidden="true"></i> Download
      </button>
      <button type="button" id="goBackBtn" class="btn btn-outline-warning btn-log-control" title="Go back" data-bs-toggle="tooltip">
        <i class="fa-solid fa-arrow-left" aria-hidden="true"></i> Back
      </button>
    </div>
  </div>
  <div id="inspectContent" class="inspect-content">
    <div id="jsonViewer"></div>
  </div>
</div>

<script>
  (function(){
    const inspectEl = document.getElementById('inspectContent');

    // Scroll to bottom on page load
    window.addEventListener('load', () => {
      inspectEl.scrollTop = inspectEl.scrollHeight;
    });

    // Scroll controls
    document.getElementById('scrollTopBtn').addEventListener('click', () => {
      inspectEl.scrollTo({ top: 0, behavior: 'smooth' });
    });

    document.getElementById('scrollBottomBtn').addEventListener('click', () => {
      inspectEl.scrollTo({ top: inspectEl.scrollHeight, behavior: 'smooth' });
    });

    document.getElementById('goBackBtn').addEventListener('click', () => {
      window.history.back();
    });

    // Download inspect data
    document.getElementById('downloadBtn').addEventListener('click', () => {
      const text = JSON.stringify({{ inspect_data | tojson }}, null, 2);
      const blob = new Blob([text], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `inspect-${'{{ container_id }}'}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // JSON Viewer
    function processString(str) {
      // Replace long hex strings with truncated versions
      return str.replace(/[a-f0-9]{20,}/gi, (match) => {
        const truncated = '...' + match.slice(-4);
        return `<span class="json-string-truncated" onclick="toggleString(this)">${truncated}</span><span class="json-string-full">${match}</span>`;
      });
    }

    function renderJSON(obj, key = '', level = 0) {
      const indent = '  '.repeat(level);
      const isExpanded = level === 0;
      const toggleSymbol = isExpanded ? '▼' : '▶';
      const displayStyle = isExpanded ? 'block' : 'none';
      if (obj === null) {
        return `<div class="json-item">${indent}<span class="json-null">${key ? key + ': ' : ''}null</span></div>`;
      }
      if (typeof obj === 'boolean') {
        return `<div class="json-item">${indent}<span class="json-boolean">${key ? key + ': ' : ''}${obj}</span></div>`;
      }
      if (typeof obj === 'number') {
        return `<div class="json-item">${indent}<span class="json-number">${key ? key + ': ' : ''}${obj}</span></div>`;
      }
      if (typeof obj === 'string') {
        const processed = processString(obj);
        return `<div class="json-item">${indent}<span class="json-string">${key ? '"' + key + '": ' : ''}"${processed}"</span></div>`;
      }
      if (Array.isArray(obj)) {
        let html = `<div class="json-item">${indent}<span class="json-toggle" onclick="toggle(this)">${toggleSymbol}</span> ${key ? '"' + key + '": ' : ''}[ <span class="json-number">${obj.length}</span> items ]<div class="json-children" style="display:${displayStyle}">`;
        obj.forEach((item, i) => {
          html += renderJSON(item, '', level + 1);
        });
        html += `${indent}</div>]</div>`;
        return html;
      }
      if (typeof obj === 'object') {
        const keys = Object.keys(obj);
        let html = `<div class="json-item">${indent}<span class="json-toggle" onclick="toggle(this)">${toggleSymbol}</span> ${key ? '"' + key + '": ' : ''}{ <span class="json-number">${keys.length}</span> properties }<div class="json-children" style="display:${displayStyle}">`;
        keys.forEach(k => {
          html += renderJSON(obj[k], k, level + 1);
        });
        html += `${indent}</div>}</div>`;
        return html;
      }
      return `<div class="json-item">${indent}${key ? key + ': ' : ''}${String(obj)}</div>`;
    }

    // Make functions globally available
    window.toggle = function(el) {
      const children = el.parentElement.querySelector('.json-children');
      if (children.style.display === 'none') {
        children.style.display = 'block';
        el.textContent = '▼';
      } else {
        children.style.display = 'none';
        el.textContent = '▶';
      }
    };

    window.toggleString = function(el) {
      const full = el.nextElementSibling;
      el.style.display = 'none';
      full.style.display = 'inline';
    };

    // Render the JSON
    const inspectData = {{ inspect_data | tojson }};
    document.getElementById('jsonViewer').innerHTML = renderJSON(inspectData);

    // --- Inspect search: highlight-only (no auto-expand) + Prev/Next match navigation ---
    let inspectMatches = [];
    let currentMatchIndex = -1; // -1 means no focused match yet

    function clearSearch() {
      // remove match highlights
      document.querySelectorAll('#jsonViewer .json-match').forEach(el => el.classList.remove('json-match','json-match-active'));
      // hide any revealed full strings and show truncated placeholders again
      document.querySelectorAll('#jsonViewer .json-string-full').forEach(el => el.style.display = 'none');
      document.querySelectorAll('#jsonViewer .json-string-truncated').forEach(el => el.style.display = '');

      // collapse all expanded children to their default collapsed state
      document.querySelectorAll('#jsonViewer .json-children').forEach(ch => {
        ch.style.display = 'none';
        const toggle = ch.parentElement ? ch.parentElement.querySelector('.json-toggle') : null;
        if (toggle) toggle.textContent = '▶';
      });
      // keep the top-level root children expanded (level 0)
      const rootItem = document.getElementById('jsonViewer')?.firstElementChild;
      if (rootItem) {
        const rootChildren = rootItem.querySelector('.json-children');
        if (rootChildren) {
          rootChildren.style.display = 'block';
          const rootToggle = rootChildren.parentElement ? rootChildren.parentElement.querySelector('.json-toggle') : null;
          if (rootToggle) rootToggle.textContent = '▼';
        }
      }

      // reset navigation state
      inspectMatches = [];
      currentMatchIndex = -1;
      updateNavButtons();
    }

    function expandAncestors(el) {
      let node = el;
      while (node && node.id !== 'jsonViewer') {
        if (node.classList && node.classList.contains('json-children')) {
          node.style.display = 'block';
          const toggle = node.parentElement.querySelector('.json-toggle');
          if (toggle) toggle.textContent = '▼';
        }
        node = node.parentElement;
      }
    }

    function updateNavButtons() {
      const prevBtn = document.getElementById('inspectPrevBtn');
      const nextBtn = document.getElementById('inspectNextBtn');
      const countEl = document.getElementById('inspectSearchCount');
      // keep badge visible and stable width; use text + dimming to indicate empty state
      if (!inspectMatches.length) {
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        countEl.textContent = '—';
        countEl.classList.add('inspect-count-empty');
        return;
      }
      // we have matches — ensure badge is active
      countEl.classList.remove('inspect-count-empty');
      if (currentMatchIndex < 0) {
        prevBtn.disabled = false;
        nextBtn.disabled = false;
        countEl.textContent = `${inspectMatches.length} match${inspectMatches.length !== 1 ? 'es' : ''}`;
      } else {
        prevBtn.disabled = currentMatchIndex <= 0;
        nextBtn.disabled = currentMatchIndex >= inspectMatches.length - 1;
        countEl.textContent = `${currentMatchIndex + 1} / ${inspectMatches.length}`;
      }
    }

    function searchInspect(query) {
      const q = (query || '').trim();
      clearSearch();
      if (!q) return;
      const ql = q.toLowerCase();
      const items = Array.from(document.querySelectorAll('#jsonViewer .json-item'));
      items.forEach(item => {
        if (item.textContent.toLowerCase().includes(ql)) {
          item.classList.add('json-match');
          inspectMatches.push(item);
        }
      });
      currentMatchIndex = -1;
      updateNavButtons();
    }

    function revealMatchAndExpand(item, ql) {
      expandAncestors(item);
      item.querySelectorAll('.json-string-full').forEach(full => {
        if (full.textContent.toLowerCase().includes(ql)) {
          full.style.display = 'inline';
          const trunc = full.previousElementSibling;
          if (trunc && trunc.classList.contains('json-string-truncated')) trunc.style.display = 'none';
        }
      });
    }

    function goToMatch(index) {
      if (!inspectMatches.length) return;
      if (index < 0) index = 0;
      if (index >= inspectMatches.length) index = inspectMatches.length - 1;
      if (currentMatchIndex >= 0 && inspectMatches[currentMatchIndex]) {
        inspectMatches[currentMatchIndex].classList.remove('json-match-active');
      }
      currentMatchIndex = index;
      const item = inspectMatches[currentMatchIndex];
      item.classList.add('json-match-active');
      const query = document.getElementById('inspectSearchInput').value.trim().toLowerCase();
      if (query) revealMatchAndExpand(item, query);
      item.scrollIntoView({ behavior: 'smooth', block: 'center' });
      updateNavButtons();
    }

    document.getElementById('inspectNextBtn').addEventListener('click', function(){
      if (!inspectMatches.length) return;
      const nextIndex = currentMatchIndex < 0 ? 0 : Math.min(currentMatchIndex + 1, inspectMatches.length - 1);
      goToMatch(nextIndex);
    });

    document.getElementById('inspectPrevBtn').addEventListener('click', function(){
      if (!inspectMatches.length) return;
      const prevIndex = currentMatchIndex < 0 ? inspectMatches.length - 1 : Math.max(currentMatchIndex - 1, 0);
      goToMatch(prevIndex);
    });

    // Wire up search input + clear button
    const searchInput = document.getElementById('inspectSearchInput');
    searchInput.addEventListener('input', (e) => searchInspect(e.target.value));
    document.getElementById('inspectSearchClear').addEventListener('click', () => { searchInput.value = ''; clearSearch(); searchInput.focus(); });

  })();
</script>
{% endblock %}